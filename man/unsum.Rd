% Generated by roxygen2 (4.1.0): do not edit by hand
% Please edit documentation in R/unsum.R
\name{unsum}
\alias{unsum}
\title{Generate unsummed adjacency matrix}
\usage{
unsum(constraints, nEdges = NULL, maxEdges = FALSE, noReturn = FALSE,
  mctSchedule = 100, hotTime = 2000, beta0 = 0.01, betaMax = 1e+05,
  mu0 = 0.1, coolingRate = 1.02, maxTime = 1e+06, minError = 0.001)
}
\arguments{
\item{constraints}{A matrix or data frame containing the row and column sums.
NA or negative values are interpretted as unconstrained.}

\item{nEdges}{Integer The desired number of edges (non-zero elements) the
adjacency matrix should have.}

\item{maxEdges}{Logical if set to TRUE then all possible edges will be used.
The number of possible edges is given by \code{\link{calcMaxEdges}}. Default
is FALSE.}

\item{noReturn}{If set to TRUE then only one directed edge can go between two
nodes. This would be appropriate if only modelling netted positions for example.
Default is FALSE.}

\item{mctSchedule}{Sets the number of MC loops between measurements. Also effects
the quench speed as beta is only changed every mctSchedule loops.}

\item{hotTime}{How many MC loops to run at the high temperature before starting
the quench. The bigger the number the more time the network has to truly
randomise before quenching.}

\item{beta0}{Starting inverse temperature. The smaller the number the hotter,
or more random, the starting configuration is.}

\item{betaMax}{The maximum beta value.}

\item{mu0}{The field that couples to the number of edges. The bigger this number
the more strict the edge restriction is during the quench.}

\item{coolingRate}{A number greater than, but close to, 1 that multiplies by \code{beta}
every \code{mctSchedule} loops.}

\item{maxTime}{The maximum number of loops before giving up on that quench and
starting again.}

\item{minError}{When the error drops below this threshold it is decided that it
is close enough to a solution. The remaining error is resolved using the row/col
iterator. A bigger number will give better performance but risks skewing the
distirbution of networks.}
}
\value{
a matrix who's row and column sums match constraints
}
\description{
Given the row and column sums for a positive weighted
adjacency matrix, this function will generate candidate matrices that are
sampled uniformly from the space of possible matrices. This is done using
simulated annealing.
}
\author{
Douglas Ashton
}

