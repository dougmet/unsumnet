---
title: "`unsumnet` Quick Start"
author: "Douglas Ashton"
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_vignette:
    fig_caption: yes
vignette: >
  %\VignetteIndexEntry{Quick Start}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

There are many networks that we are interested in for which we only have aggregated data instead of the full structure. For example, in financial networks we often know the balance sheets (total assets and liabilities) of the individual institutions without knowing detailed exposure.

In matrix notation, the information we have is the row and column sums of the weighted adjacency network, $AW_{ij}$.

$$ R_i = \sum_j AW_{ij} $$
$$ C_i = \sum_j AW_{ji} $$

In general there are many possible networks that could satisfy these constraints. The aim of the `unsumnet` package is to evenly sample from these networks while allowing the user to choose the sparsity (number of edges).

As a demonstation consider the following fictional banking system. The true loans network is a weighted adjacency matrix as below

```{r}
library(unsumnet)

neastTrue
```

## Creating a network

```{r}
set.seed(11)
fit <- unsum(neast, 12)
fit$AW
```

The following settings allow us to see the network with the `igraph` package

```{r}
library(igraph)
plotUnsum <- function(aw) {
  g <- graph.adjacency(aw, weighted = TRUE)
  V(g)$size <- 50
  V(g)$color <- 'gold'
  if(!is.null(dimnames(aw)))
    V(g)$label <- dimnames(aw)[[1]]
  lo <- layout.circle(g)
  sw <- sum(aw)/50
  plot(g, edge.width=E(g)$weight/sw, edge.curved=is.mutual(g), layout=lo,
       margin=c(0,0,0,0))
}

plotUnsum(fit$AW)
```





Run through unsum and a few easy options. One with all the defaults, one with a few more options set.

## Maximum Entropy Solution

```{r, fig.show='hold', fig.cap="hello"}
plotUnsum(neastTrue)
neastME <- maxEntropy(neast)
plotUnsum(neastME)
```


