---
title: "`unsumnet` Introduction"
author: "Douglas Ashton"
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_vignette:
    fig_caption: yes
vignette: >
  %\VignetteIndexEntry{Introduction}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

There are many networks that we are interested in for which we only have aggregated data instead of the full structure. For example, in financial networks we often know the balance sheets (total assets and liabilities) of the individual institutions without knowing detailed exposure.

In matrix notation, the information we have is the row and column sums of the weighted adjacency network, $AW_{ij}$.

$$ R_i = \sum_j AW_{ij} $$
$$ C_i = \sum_j AW_{ji} $$

In general there are many possible networks that could satisfy these constraints. The aim of the `unsumnet` package is to evenly sample from these networks while allowing the user to choose the sparsity (number of edges).

## Aggregated Data

Consider the following fictional banking system. It consists of six banks and we know the total outgoing commitments (loans made) and incoming commitments (loans received).

```{r echo=FALSE}
options(digits = 2)
```


```{r}
library(unsumnet)
neast
```

These values are the row and column sums of an unknown matrix, `rowSums(neastTrue)` and `colSums(neastTrue)`. The primary function of this package is to find networks that fit these summed data. We wish to "unsum" the network.

## Creating a network

The `unsum` function allows us to explore networks with the number of edges, `nEdges` as a control parameter. To make one network with 12 edges we simply call

```{r}
set.seed(11)
fit <- unsum(neast, 12)

# The weighted adjacency matrix
fit$AW

# Check it matches the constraints
rowSums(fit$AW)
colSums(fit$AW)

```

The following settings allow us to see the network with the `igraph` package

```{r}
library(igraph)
plotUnsum <- function(aw) {
  g <- graph.adjacency(aw, weighted = TRUE)
  V(g)$size <- 50
  V(g)$color <- 'gold'
  if(!is.null(dimnames(aw)))
    V(g)$label <- dimnames(aw)[[1]]
  lo <- layout.circle(g)
  sw <- mean(aw)/2
  plot(g, edge.width=E(g)$weight/sw, edge.curved=is.mutual(g), layout=lo,
       margin=c(0,0,0,0))
}

plotUnsum(fit$AW)
```



## Maximum Entropy Solution

```{r, fig.show='hold', fig.cap="hello"}
plotUnsum(neastTrue)
neastME <- maxEntropy(neast)
plotUnsum(neastME)
```


